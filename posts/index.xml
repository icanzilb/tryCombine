<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on try Code</title>
    <link>https://trycombine.com/posts/</link>
    <description>Recent content in Posts on try Code</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 05 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://trycombine.com/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Marin&#39;s Side Projects 2023</title>
      <link>https://trycombine.com/posts/marin-side-projects-2023/</link>
      <pubDate>Tue, 05 Dec 2023 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/marin-side-projects-2023/</guid>
      <description>For one reason or another I didn&amp;rsquo;t do much publicly in 2023 but in the last couple months I had some free time and picked some ideas from the backlog to work on.
So here&amp;rsquo;s a short summary of few interesting things I worked on in 2023 (some with source code, yay):
Breadcrumbs I&amp;rsquo;ve had this idea for a very long time and I believe that it could be a great app if anyone could come up with a business model to sustain its development.</description>
    </item>
    
    <item>
      <title>Easy app walkthroughs with MarkWalkthrough</title>
      <link>https://trycombine.com/posts/a-fun-swiftui-package-for-creating-walkthroughs/</link>
      <pubDate>Mon, 04 Dec 2023 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/a-fun-swiftui-package-for-creating-walkthroughs/</guid>
      <description>Some time ago, while I was working on my app Rex Tables, I wrote some quick code that reads a Markdown file with some &amp;ldquo;slide&amp;rdquo; data and automatically displays an app walkthrough.
It wasn&amp;rsquo;t really meant for other people to use since it made use of a paid Swift package for the transition effects in the walkthrough. But that package, namely Pow, just become open sourced last week!
So I pulled the code out of Rex Tables and did a quick pass to tighten up a couple of things and pushed it to GitHub.</description>
    </item>
    
    <item>
      <title>Injecting code in result builders</title>
      <link>https://trycombine.com/posts/an-example-of-using-arbitrary-code-in-result-builders/</link>
      <pubDate>Thu, 30 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/an-example-of-using-arbitrary-code-in-result-builders/</guid>
      <description>This is a rather quick post about running some arbitrary code inside result builders.
Result builders are great and often make the code much more readable ‚Äî think SwiftUI vs UIKit&amp;hellip; but builder blocks are quite strict about the types they expect to find so using arbitrary prints or calling other functions isn&amp;rsquo;t always easy, per s√®.
I am often times a fan of inserting a print or two in the code, especially when I&amp;rsquo;m exploring new code.</description>
    </item>
    
    <item>
      <title>DocC: Project documentation structure</title>
      <link>https://trycombine.com/posts/an-example-docc-documentation-for-an-ios-app/</link>
      <pubDate>Wed, 20 Sep 2023 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/an-example-docc-documentation-for-an-ios-app/</guid>
      <description>This post is about structuring the documentation for a project with Swift DocC. (Apple&amp;rsquo;s intro to Swift DocC)
Swift DocC in Xcode automatically builds project documentation following the structure of the app&amp;rsquo;s code hierarchy. Additionally, DocC allows you to create custom curation and hierarchy to improve the discoverability and the user experience of said documentation.
Bellow I&amp;rsquo;ll suggest a simple documentation hierarchy for apps or packages, especially in the context of a larger team or organization.</description>
    </item>
    
    <item>
      <title>Automate debugging SwiftUI and UIKit with dataFude</title>
      <link>https://trycombine.com/posts/code-samples-on-how-to-approach-debugging-swift-and-uikit-apps/</link>
      <pubDate>Tue, 03 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/code-samples-on-how-to-approach-debugging-swift-and-uikit-apps/</guid>
      <description>The ability to log values and visualize them in dataFude is quite powerful, but the core concept of the app really shines when a developer automates logs that drive metrics over time.
Such metrics could be any value that changes over time, such as the size of the app cache, the amount of RAM consumed, or the number of instances created of a given class.
This article will look at two quite different approaches to tracking automation, one with SwiftUI and another with UIKit.</description>
    </item>
    
    <item>
      <title>dataFude for Simulator launches today! üöÄ</title>
      <link>https://trycombine.com/posts/datafude-for-simulator-is-on-the-appstore-now/</link>
      <pubDate>Tue, 03 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/datafude-for-simulator-is-on-the-appstore-now/</guid>
      <description>I&amp;rsquo;m glad to share that dataFude for Simulator is launching today on ProductHunt and the AppStore!
dataFude for Simulator is an Xcode companion app to see your debugging data in a beautiful and bold UI. Log your debug data as usual using Apple&amp;rsquo;s logging framework, and dataFude for Simulator will automatically select and display your logs!
It&amp;rsquo;s a powerful native developer tool that is focused on making developers more productive while developing with Xcode and the Simulator.</description>
    </item>
    
    <item>
      <title>Automation tooling using MarkCodable for reports</title>
      <link>https://trycombine.com/posts/using-markcodable-to-generate-reports/</link>
      <pubDate>Thu, 08 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/using-markcodable-to-generate-reports/</guid>
      <description>For my apps dataFude for Simulator and Rex Tables I have few command line tools that run some end-to-end tests. I use MarkCodable to easily print reports to the console. In this short post I&amp;rsquo;m gonna show how MarkCodable cuts down on some of the turnaround time when I&amp;rsquo;m making tools.
MarkCodable I wrote about MarkCodable previously when I released it: Introducing MarkCodable but I wanted to give you some more examples, just for fun.</description>
    </item>
    
    <item>
      <title>Custom SwiftUI view modifier for paid app features</title>
      <link>https://trycombine.com/posts/custom-view-modifier-to-handle-features-that-are-only-enabled-in-the-pro-version-of-the-app/</link>
      <pubDate>Mon, 05 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/custom-view-modifier-to-handle-features-that-are-only-enabled-in-the-pro-version-of-the-app/</guid>
      <description>In my app dataFude for Simulator I&amp;rsquo;ve decided to offer some features for free and others only to users who pay for the app.
This way, everyone including students and hobbyist can meaningfully use the app, while professional users can support the development.
I considered few different approaches including compiling two separate versions of the app, but ultimately went for shipping a single binary that relies on RevenueCat and enables/disables some parts of the UI depending on the purchase status.</description>
    </item>
    
    <item>
      <title>dataFude for Simulator - public beta on TestFlight now!</title>
      <link>https://trycombine.com/posts/datafude-for-simulator-public-beta-on-testflight-now/</link>
      <pubDate>Tue, 29 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/datafude-for-simulator-public-beta-on-testflight-now/</guid>
      <description>As I wrote recently, in 2022 I worked on a lot of side projects and even made a shippable and usable versions of few of them.
Many of the ideas I worked on converged in the latest app that I believe is a product a large number of developers could use to improve their daily lives.
Yesterday, I opened up dataFude for Simulator for public testing on TestFlight. If you want to give it a try or learn more, the website is:</description>
    </item>
    
    <item>
      <title>My favorite 12 side projects in 2022</title>
      <link>https://trycombine.com/posts/12-of-my-favorite-side-projects-in-2022/</link>
      <pubDate>Mon, 07 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/12-of-my-favorite-side-projects-in-2022/</guid>
      <description>Looking back at 2022, I worked on a whole lot of side projects. I do this mostly for learning purposes, solving problems that I personally have in my own workflow.
This year I did a lot of &amp;ldquo;development live threads&amp;rdquo;. I&amp;rsquo;d make coffee in the morning and pull an idea out of my backlog and see how far can I get it by about lunch time. I post screenshots or comments every 10-20 minutes and a lot of people engage on twitter during the time.</description>
    </item>
    
    <item>
      <title>Introducing: Got Jobs?</title>
      <link>https://trycombine.com/posts/introducing-got-jobs/</link>
      <pubDate>Sun, 06 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/introducing-got-jobs/</guid>
      <description>Today I&amp;rsquo;m releasing a Safari extension on the Mac App Store called &amp;ldquo;Got Jobs?&amp;rdquo;.
This new extension lets you ask any website that you&amp;rsquo;re browsing: &amp;ldquo;Got Jobs?&amp;rdquo; by pressing Cmd+Shift+J.
That&amp;rsquo;s it. That&amp;rsquo;s the extension.
I&amp;rsquo;ve been using it since summer and it still sometimes feels like magic!
Got Jobs? &amp;ldquo;Got Jobs?&amp;rdquo; is a game-changing time saver for people who are actively or casually browsing for new opportunities.
This Safari extension makes finding and opening the Jobs/Careers page on the currently visited website as simple as pressing Cmd+Shift+J.</description>
    </item>
    
    <item>
      <title>Introducing MarkCodable</title>
      <link>https://trycombine.com/posts/introducing-markcodable/</link>
      <pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/introducing-markcodable/</guid>
      <description>I had a lot of fun listening to &amp;ldquo;A releational database using Markdown&amp;rdquo; episode with John Sundell and Gui Rambo:
After taking a moment though, I started realizing that there is a whole plethora of use cases where Markdown could be a great storage for some of my data. Markdown supports tables and they are pretty easy to view, parse and edit by hand.
On the other hand, JSON isn&amp;rsquo;t very easy to view or edit by hand, which is sometimes more important for me, given I work on a lot of small tooling that automates or performs specific tasks and usually doesn&amp;rsquo;t need a large dataset.</description>
    </item>
    
    <item>
      <title>Introducing timeui</title>
      <link>https://trycombine.com/posts/introducing-timeui/</link>
      <pubDate>Sun, 20 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/introducing-timeui/</guid>
      <description>A little while ago I coded a minimal profiling tool for the macOS command line and called it timeui. Last week I pushed the source code online in the hope other people would like it and use it (and eventually contribute some code too).
In this post I&amp;rsquo;ll introduce you quickly to timeui and what it can currently do for you.
What is timeui? timeui is a command line tool that profiles an app you provide it and shows duration, apple&amp;rsquo;s universal logging intervals, CPU usage and memory footprint:</description>
    </item>
    
    <item>
      <title>Optimization in Swift, part 4</title>
      <link>https://trycombine.com/posts/swift-performance-concurrency-4/</link>
      <pubDate>Mon, 14 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-performance-concurrency-4/</guid>
      <description>In Part 3 I wrote about trying to optimize my filter code by using an unsafe API from the standard library. This helped a tiny bit but barely improved the performance of my initial fictional use case (all about the test setup you can find out in Part 1).
Updating the Memory Buffer Concurrently Looking at the results of both code variants so far, I got an idea ‚Äî I could fuse together using concurrency to do the collection filtering and using a buffer in memory so I can update the array storage directly.</description>
    </item>
    
    <item>
      <title>Optimization in Swift, part 3</title>
      <link>https://trycombine.com/posts/swift-performance-concurrency-3/</link>
      <pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-performance-concurrency-3/</guid>
      <description>In Part 2 I wrote about trying to optimize a very tight filter function with async/await. This helped when the filter performs some heavy work for each of the collection elements but not with my initial fictional use case (all about the test setup you can find out in Part 1).
Taking to the Standard Library Since I already know that I&amp;rsquo;m not going to keep pushing the async/await variant of the code, I think it&amp;rsquo;s a good idea to look into the standard library.</description>
    </item>
    
    <item>
      <title>Optimization in Swift, part 2</title>
      <link>https://trycombine.com/posts/swift-performance-concurrency-2/</link>
      <pubDate>Wed, 09 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-performance-concurrency-2/</guid>
      <description>In Part 1 I wrote what this mini-series would be all about. Given the default array filtering is a performance bottleneck for my fictional app, I&amp;rsquo;m going to explore if I can write code that performs better in my specific use case.
In this part, I&amp;rsquo;m going to rewrite my initial filtering function and use the new async/await Swift concurrency syntax.
An async filter function Since TaskGroup still has a performance issue in the current version of Swift, I&amp;rsquo;ll use a simplified code that uses only top tasks (e.</description>
    </item>
    
    <item>
      <title>Optimization in Swift, part 1</title>
      <link>https://trycombine.com/posts/swift-performance-concurrency-1/</link>
      <pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-performance-concurrency-1/</guid>
      <description>This will be yet another exploratory series on my blog ‚Äî this time around, I want to write a little about optimizing performance in Swift code. This is, of course, an endless topic so what I&amp;rsquo;m going to do is, similarly to previous posts, focus on a problem and then track my way through working on it.
Also, since this might turn into a somewhat longer read, I thought I&amp;rsquo;d split it into several short parts; so if you are in fact interested to read through you don&amp;rsquo;t have to put in all the time at once.</description>
    </item>
    
    <item>
      <title>TaskGroup as a workflow design tool</title>
      <link>https://trycombine.com/posts/swift-concurrency-task-group-workflow/</link>
      <pubDate>Mon, 21 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-concurrency-task-group-workflow/</guid>
      <description>For my talk at iOS Conf SG 2022 I wanted to showcase some Swift concurrency use-cases that don&amp;rsquo;t fall into the common scenarios. Revisiting the slides some weeks later, I think it&amp;rsquo;d be fun to cover my TaskGroup example in more detail.
In this post I&amp;rsquo;ll show how to use TaskGroup to design a complete (but fictional) user login-sequence.
What is TaskGroup good for? Most examples floating around show using a TaskGroup to add a number of identical tasks to a group and execute them concurrently.</description>
    </item>
    
    <item>
      <title>The issue with task groups or how I discovered a solved problem</title>
      <link>https://trycombine.com/posts/swift-concurrency-task-group/</link>
      <pubDate>Wed, 16 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-concurrency-task-group/</guid>
      <description>This post is not my usual format but there is a moral at the end, so hang around if you have a little time to waste.
The setup I&amp;rsquo;m working on a longer blog post about the process of optimizing some concurrency Swift code. At a point I used John Sundell&amp;rsquo;s CollectionConcurrencyKit to compare the performance of different approaches.
After I had my numbers, I peaked into his code to double check what exactly am I measuring.</description>
    </item>
    
    <item>
      <title>Swift Light IDE update, Jan 31st</title>
      <link>https://trycombine.com/posts/swift-light-ide-update-jan/</link>
      <pubDate>Mon, 31 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-light-ide-update-jan/</guid>
      <description>For the ones who missed it last November, I&amp;rsquo;ve been playing with a Swift IDE prototype which allows you to easily develop Swift scripts for the mac.
I shared a video showcase demoing how the tight integration of the IDE with the toolchain allows you to write scripts, capture inputs and outputs, and all that in a neat SwiftUI interface:
More than anything else I worked on this to explore and demonstrate how easily I can build powerful Swift tools.</description>
    </item>
    
    <item>
      <title>Yielding accessors in Swift</title>
      <link>https://trycombine.com/posts/swift-read-modify-coroutines/</link>
      <pubDate>Tue, 25 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-read-modify-coroutines/</guid>
      <description>Edit: The post previsouly said yielding accessors were available only in nightly toolchains, but _read and _modify are also available in release Swift builds; they&amp;rsquo;re just _ prefixed to signify they are work-in-progress.
It seems that Swift 5.6 is shaping up to a great iteration of the language and will bring a round improvements to performance-critical Swift code.
I was reading through a pitch by Joe Groff on some improvements to ARC and ownership the other day when I noticed that he mentions that accessor coroutines are available in Swift trunk.</description>
    </item>
    
    <item>
      <title>Swift Async Sequence extensions (part 2)</title>
      <link>https://trycombine.com/posts/swift-async-sequence-extensions-2/</link>
      <pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-async-sequence-extensions-2/</guid>
      <description>In Swift Async Sequence extensions (part 1) I covered simple ways to create an async sequence using a custom factory method and binding a sequence to a UI control via a custom assign method.
This covered the &amp;ldquo;beginning&amp;rdquo; and &amp;ldquo;end&amp;rdquo; of the data stream (so to say) but what about processing or converting the data along the way? If you draw a parallel to Combine code ‚Äî how would you build custom &amp;ldquo;operators&amp;rdquo; for your async sequence?</description>
    </item>
    
    <item>
      <title>Swift Async Sequence extensions (part 1)</title>
      <link>https://trycombine.com/posts/swift-async-sequence-extensions-1/</link>
      <pubDate>Wed, 19 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-async-sequence-extensions-1/</guid>
      <description>I&amp;rsquo;ve been trying out various ways to extend and build upon the currently available Concurrency APIs introduced in Swift 5.5
I believe the Concurrency APIs are intentionally somewhat minimal so that developers would intentionally fall back on Combine for complex tasks. Maybe I&amp;rsquo;m right or wrong but I can see how a lot of people will want to extend the Concurrency APIs to suit better their current tasks.
In this post I&amp;rsquo;ll code a couple of extensions that show how to easily build your own concurrent power-ups.</description>
    </item>
    
    <item>
      <title>Extending Xcode with power-ups</title>
      <link>https://trycombine.com/posts/xcode-powerups/</link>
      <pubDate>Mon, 20 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/xcode-powerups/</guid>
      <description>In this post I describe the technical setup of a small language experiment I developed to aid myself working on custom Xcode instruments.
The need for a more flexible coding inside Xcode Last month, I prototyped a Swift IDE and became very interested in enhancing the experience of building with Swift. (Since Apple doesn&amp;rsquo;t hire remotely, I wonder what other companies are working in that area?)
A little later, I came back to updating my custom Xcode Instrument called Timelane to support debugging new code based on the new Swift modern concurrency APIs:</description>
    </item>
    
    <item>
      <title>Announcing: ‚ÄúModern Concurrency in Swift‚Äù</title>
      <link>https://trycombine.com/posts/announcing-modern-swift-concurrency-book/</link>
      <pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/announcing-modern-swift-concurrency-book/</guid>
      <description>I&amp;rsquo;m incredibly happy to share that today the new raywenderlich.com book &amp;ldquo;Modern Concurrency in Swift&amp;rdquo;, that I&amp;rsquo;ve been working on, is available at swiftconcurrencybook.com!
Together with editors Sandra Grauschopf, Felipe Laso-Marsetti, Richard Turton, and Shai Mishali, we&amp;rsquo;ve been working very hard to get a book out as soon as possible on the newly released in 2021 Swift Concurrency:
The book is written in the classic raywenderlich.com style that mixes key pieces of theory with step-by-step instructions, guiding the readers through working on practical, real-life projects.</description>
    </item>
    
    <item>
      <title>Actors, the cooperative pool and concurrency</title>
      <link>https://trycombine.com/posts/swift-actor-dispatch-queues-concurrency/</link>
      <pubDate>Wed, 06 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-actor-dispatch-queues-concurrency/</guid>
      <description>After I started doing some benchmarking how different APIs perform, when used to build a simple counter, I got really interested to learn more about how the new Swift concurrency model behaves at runtime.
So in this post I&amp;rsquo;ll use a couple of actors and make them do concurrent computations and check how the thread list and dispatch-queues look like in the debugger.
The Test Setup I&amp;rsquo;ve prepared a super-duper simple SwiftUI app that does a bunch of floating-point multiplication and division.</description>
    </item>
    
    <item>
      <title>Performance: Actor vs queue vs lock</title>
      <link>https://trycombine.com/posts/performance-actor-queue-lock-benchmark/</link>
      <pubDate>Thu, 30 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/performance-actor-queue-lock-benchmark/</guid>
      <description>I do a lot of performance and instrumenting work and I&amp;rsquo;ve found Peter Steinberger&amp;rsquo;s post here very useful when comparing lock alternatives.
As I worked with async/await and actors more and more this summer, I thought it‚Äôd be nice to put together a short post offering some basic benchmarking of actors vs. the existing synchronization mechanisms.
Disclaimer Benchmarking depends heavily on the system, temporary conditions, and more. As with any amateur benchmarks, take the numbers in this post with a grain of salt.</description>
    </item>
    
    <item>
      <title>The difference between Thread.sleep() and Task.sleep()</title>
      <link>https://trycombine.com/posts/thread-task-sleep/</link>
      <pubDate>Mon, 13 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/thread-task-sleep/</guid>
      <description>With the work-in-progress backport of the new Swift concurrency model all the way to iOS13, async/await and friends are getting more and more relevant for all Swift developers.
So here&amp;rsquo;s a quick and simple example that showcases some of the nice features of the new concurrency model without going into much detail.
Thread.sleep() vs Task.sleep() Let&amp;rsquo;s just look at the old and new sleep APIs:
Thread.sleep() is the old API that blocks a thread for the given amount of seconds ‚Äî it doesn&amp;rsquo;t load the CPU, the core just idles.</description>
    </item>
    
    <item>
      <title>Bridge from Combine to AsyncSequence - the code (p. 2)</title>
      <link>https://trycombine.com/posts/combine-async-sequence-2/</link>
      <pubDate>Tue, 13 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/combine-async-sequence-2/</guid>
      <description>Yesterday I wrote about AsyncSequence, AsyncStream and a simple plan how to bridge (or proxy) Combine publishers to the new asynchronous sequences APIs - Bridge from Combine to AsyncSequence - the plan (part 1).
Today let&amp;rsquo;s put together the code as planned and see if that&amp;rsquo;s going to work out so we can easily use publishers as async sequences.
CombineAsyncStream setup I&amp;rsquo;ll create a new type called CombineAsyncStream and make it conform to AsyncSequence.</description>
    </item>
    
    <item>
      <title>Bridge from Combine to AsyncSequence - the plan (p. 1)</title>
      <link>https://trycombine.com/posts/combine-async-sequence-1/</link>
      <pubDate>Mon, 12 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/combine-async-sequence-1/</guid>
      <description>Previously, I wrote about actors in Actors part 1 and Actors part 2; this time I&amp;rsquo;m going to cover how to write a Combine operator to proxy a Combine publisher into an async sequence that you can iterate over by using a simple for loop.
Note: The current version of Xcode 13 is beta 2 and I&amp;rsquo;m going to be using the latest swift.org toolchain nightly snapshot in order to make use of AsyncStream.</description>
    </item>
    
    <item>
      <title>Swift Actors: A practical example, part 2</title>
      <link>https://trycombine.com/posts/swift-actors-combine/</link>
      <pubDate>Wed, 12 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-actors-combine/</guid>
      <description>In my previous post Swift Actors: A practical example, part 1 I covered how I got a Swift.org toolchain from trunk, enabled support for the currently experimental support for structured concurrency, and created a thread-safe cache in few lines of Swift code.
If you missed part 1, definitely do read it first as this post builds upon the code I already covered there. ¬ª
When I wrapped up writing part 1, I was looking at my new cache actor and I started wondering &amp;ldquo;What about Combine?</description>
    </item>
    
    <item>
      <title>Swift Actors: A practical example, part 1</title>
      <link>https://trycombine.com/posts/swift-actors/</link>
      <pubDate>Mon, 10 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-actors/</guid>
      <description>I&amp;rsquo;ve been re-reading the Swift structured concurrency roadmap and the Swift actors proposal and noticed a note on the latter saying:
&amp;ldquo;Partially available in recent main snapshots behind the flag -Xfrontend -enable-experimental-concurrency&amp;rdquo;
So, naturally ü§ì, I downloaded the latest snapshot from Swift.org and took it for a spin to try out some actor code!
Installing Swift toolchain with actors support Huge disclaimer: this is all experimental experience using a trunk code not cut into a release.</description>
    </item>
    
    <item>
      <title>Using self, weak, and unowned in Combine</title>
      <link>https://trycombine.com/posts/self-weak-unowned/</link>
      <pubDate>Wed, 03 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/self-weak-unowned/</guid>
      <description>Updated with more examples on Mar 6th, 2021.
One of the most often asked questions in the Combine and RxSwift slack channels is something along the lines of:
Should I use self, weak, or unowned with my reactive code?
Given that most operators take closures, it&amp;rsquo;s a fair question. In this post I&amp;rsquo;ll go over common scenarios for using weak, unowned or simply self and include links with more information at the bottom.</description>
    </item>
    
    <item>
      <title>Owning AnyCancellable with Cancellor</title>
      <link>https://trycombine.com/posts/cancellor/</link>
      <pubDate>Fri, 05 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/cancellor/</guid>
      <description>Swift 5.4 officially introduces @resultBuilder, which is a way to create custom DSLs and generally create more semantic APIs (think of the way you write SwiftUI today).
I wanted to play with it and create something useful for Combine developers so I thought &amp;ldquo;Would it not be handy to batch-add publisher subscriptions to an owned list of cancellables?&amp;rdquo;.
I remembered back in the day I used an extension on NSObject that adds automatically a dispose bag to all objects in case you need one created by Ash Furrow and I thought I&amp;rsquo;d put together something in the same fashion.</description>
    </item>
    
    <item>
      <title>5 Stranger Things you can do with Timelane at NSSpain</title>
      <link>https://trycombine.com/posts/timelane-nsspain-2020/</link>
      <pubDate>Fri, 20 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/timelane-nsspain-2020/</guid>
      <description>For my talk at NSSpain 2020 I&amp;rsquo;ve prepared a beyond-the-basics Timelane talk.
I think everyone who&amp;rsquo;s heard about Timelane by now knows what it does for its simplest use case - debugging some Combine based code. However, you can do much, much more with Timelane!
So for my NSSpain 2020 talk I prepared 5 little examples on how to use Timelane beyond the simplest use case.
I&amp;rsquo;ve pushed all the demo apps I use in my talk to this repository: https://github.</description>
    </item>
    
    <item>
      <title>How to create a custom instrument on top of Timelane!</title>
      <link>https://trycombine.com/posts/how-to-create-custom-instrument/</link>
      <pubDate>Sun, 19 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/how-to-create-custom-instrument/</guid>
      <description>You can easily log data in Instruments by using the functions in Apple&amp;rsquo;s os framework. All you need is to use os_log(&amp;hellip;) and that will log data in Instruments. If you&amp;rsquo;d like to read more about this check out Recording Performance Data Apple article.
Creating a real custom instrument, however, is a little more complicated as you can learn in Creating Custom Instruments WWDC2018 video and it involves XML, CLIPS, and more complex stuff.</description>
    </item>
    
    <item>
      <title>Timelane - the first two weeks!</title>
      <link>https://trycombine.com/posts/timelane-combine-update/</link>
      <pubDate>Fri, 13 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/timelane-combine-update/</guid>
      <description>It&amp;rsquo;s been two weeks since I released Timelane and I&amp;rsquo;m really humbled by the community&amp;rsquo;s super positive response.
Since much has happened since the launch, I&amp;rsquo;m writing this to give everyone a detailed update.
The current versions are as follows:
TimelaneCombine 1.0.4 RxTimelane 1.0.3 TimelaneCore 1.0.3 I&amp;rsquo;ve merged 18 PRs (in the 14 days since launch!) on all Timelane repos and I pushed some changes myself too.
Here&amp;rsquo;s a summary of what&amp;rsquo;s new.</description>
    </item>
    
    <item>
      <title>Announcing: Timelane</title>
      <link>https://trycombine.com/posts/announcing-timelane-combine/</link>
      <pubDate>Fri, 28 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/announcing-timelane-combine/</guid>
      <description>Today I&amp;rsquo;m announcing the public release of Timelane.
Timelane is a free, open source Instrument that helps you profile and debug asynchronous code.
Timelane is available today on: http://timelane.tools.
The Timelane Instrument leverages signpost logging and the powerful Instruments UI to help you visually inspect asynchronous subscriptions and drill down through logged events over time.
Installation Install the latest build from http://timelane.tools or fork the repository on GitHub and build the app yourself.</description>
    </item>
    
    <item>
      <title>Property Wrappers with Combine</title>
      <link>https://trycombine.com/posts/combine-property-wrappers/</link>
      <pubDate>Wed, 11 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/combine-property-wrappers/</guid>
      <description>In this post I&amp;rsquo;ll look into making more out of Combine code by using the newly introduced in Swift 5.1: Property Wrappers.
Let&amp;rsquo;s very quickly go into what property wrappers are in general and then dive into a Combine example.
Swift Property Wrappers Property wrappers are a new feature in Swift 5.1 that allows you to abstract redundant functionality around handling type properties.
Property wrappers are very handy in (my experience so far ü§ì ) two ways:</description>
    </item>
    
    <item>
      <title>subscribe(on:) vs receive(on:)</title>
      <link>https://trycombine.com/posts/subscribe-on-receive-on/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/subscribe-on-receive-on/</guid>
      <description>In this post, instead of looking into the basics of multi-threading with Combine, we are going to have a look at the difference between subscribe(on:) and receive(on:) specifically.
We&amp;rsquo;re going to look at a typical subscription chain starting with a root publisher, a couple of operators, and a subscriber at the end.
We&amp;rsquo;ll look into more diagrams and some example code of how subscribe(on:) and receive(on:) affect subscriptions.
subscribe(on:) subscribe(on:) sets the scheduler on which you&amp;rsquo;d like the current subscription to be &amp;ldquo;managed&amp;rdquo; on.</description>
    </item>
    
    <item>
      <title>Binding a list with multiple sections and different cells</title>
      <link>https://trycombine.com/posts/combinedatasources-multiple-sections/</link>
      <pubDate>Sat, 07 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/combinedatasources-multiple-sections/</guid>
      <description>Today&amp;rsquo;s post showcases another real-life use case of using CombineDataSources, namely binding a list to a table view with multiple sections using different cell types.
In my last post Binding a simple list to a UITableView we had a look at binding a list of data elements to a table view. It&amp;rsquo;s pretty simple to bind a plain table view when you have a coherent list of elements.
In this post I&amp;rsquo;m gonna show some code on how to bind a list to a table with multiple sections that also needs to use different cell types for the different sections.</description>
    </item>
    
    <item>
      <title>Binding a simple list to a UITableView</title>
      <link>https://trycombine.com/posts/combinedatasources-simple-static-list/</link>
      <pubDate>Tue, 03 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/combinedatasources-simple-static-list/</guid>
      <description>While still keep improving the current version of CombineDataSources I tought it&amp;rsquo;d be nice to post few articles on the current API design along with some code samples.
This would be nice in order to get some feedback and to try putting some of the code in context.
CombineDataSources Introduction RxSwiftCommunity&amp;rsquo;s excellent RxDataSources allows developers to reactively bind data to table and collection views. It uses a lot of the underlaying structure of RxSwift and it&amp;rsquo;s very powerful.</description>
    </item>
    
    <item>
      <title>An assert operator: assertMaxSubscriptions()</title>
      <link>https://trycombine.com/posts/assert-max-subscriptions/</link>
      <pubDate>Thu, 29 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/assert-max-subscriptions/</guid>
      <description>While I keep working on CombineDataSources I&amp;rsquo;ve faced some of the differences between RxSwift and Combine and those are slowing me down a bit.
For example: in RxSwift when dealing with UI I&amp;rsquo;d usually use shareReplayLatestWhileConnected() - this operator shares an observable and emits the latest value to all subscribers downstream. In Combine there is currently a share() operator which does a similar thing but does not &amp;ldquo;replay&amp;rdquo; the latest value.</description>
    </item>
    
    <item>
      <title>Debug logging with CombinePrintout</title>
      <link>https://trycombine.com/posts/debug-logging-combineprintout/</link>
      <pubDate>Fri, 16 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/debug-logging-combineprintout/</guid>
      <description>Logging is a really powerful way to debug code, especially if it&amp;rsquo;s asynchronous code that runs in a time sensitive way so stepping through the debugger is a pain.
In Simple custom Combine operators I wrote about how to create an operator that logs to the system Console app in just few lines.
After playing with Combine some more I went ahead and created a micro framework called &amp;ldquo;CombinePrintout&amp;rdquo; that adds few convenient methods to Combine allowing you to quickly print information about your subscriptions.</description>
    </item>
    
    <item>
      <title>Building a custom `sample` operator</title>
      <link>https://trycombine.com/posts/more-simple-custom-combine-operators-with-sample/</link>
      <pubDate>Tue, 06 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/more-simple-custom-combine-operators-with-sample/</guid>
      <description>In Simple custom Combine operators I spoke about how you can cheaply create your own custom Combine operator without the need to create a new custom Publisher type.
In this post I&amp;rsquo;d like to show how this kind of &amp;ldquo;cheap&amp;rdquo; operators could actually be quite complex and useful; still being created only by creatively combining existing operators.
Let&amp;rsquo;s look at sample(_)&amp;hellip;
The sample operator rxmarbles.com is a marveleous website where you can find visual and interactive presentations of a multitude of reactive operators (based in their implementation in RxJS).</description>
    </item>
    
    <item>
      <title>Simple custom Combine operators</title>
      <link>https://trycombine.com/posts/simple-custom-combine-operators/</link>
      <pubDate>Fri, 02 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/simple-custom-combine-operators/</guid>
      <description>Creating simple custom operators is very straightforward in Combine.
As long as your custom operator can be expressed via combining existing operators you don&amp;rsquo;t need to create a new publisher type - you can simply extend the Publisher protocol with your own custom operator.
Let&amp;rsquo;s try quickly creating one now.
Extending Publisher You can extend Publisher like any other protocol in Swift. For this post I&amp;rsquo;ll create a debugging operator that writes logs to the system console.</description>
    </item>
    
  </channel>
</rss>

<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>try Combine</title>
    <link>http://trycombine.com/</link>
    <description>Recent content on try Combine</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 09 Sep 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://trycombine.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>subscribe(on:) vs receive(on:)</title>
      <link>http://trycombine.com/posts/subscribe-on-receive-on/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>http://trycombine.com/posts/subscribe-on-receive-on/</guid>
      <description>In this post, instead of looking into the basics of multi-threading with Combine, we are going to have a look at the difference between subscribe(on:) and receive(on:) specifically.
We&amp;rsquo;re going to look at a typical subscription chain starting with a root publisher, a couple of operators, and a subscriber at the end.
We&amp;rsquo;ll look into more diagrams and some example code of how subscribe(on:) and receive(on:) affect subscriptions.
subscribe(on:) subscribe(on:) sets the scheduler on which you&amp;rsquo;d like the current subscription to be &amp;ldquo;managed&amp;rdquo; on.</description>
    </item>
    
    <item>
      <title>Binding a list with multiple sections and different cells</title>
      <link>http://trycombine.com/posts/combinedatasources-multiple-sections/</link>
      <pubDate>Sat, 07 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>http://trycombine.com/posts/combinedatasources-multiple-sections/</guid>
      <description>Today&amp;rsquo;s post showcases another real-life use case of using CombineDataSources, namely binding a list to a table view with multiple sections using different cell types.
In my last post Binding a simple list to a UITableView we had a look at binding a list of data elements to a table view. It&amp;rsquo;s pretty simple to bind a plain table view when you have a coherent list of elements.
In this post I&amp;rsquo;m gonna show some code on how to bind a list to a table with multiple sections that also needs to use different cell types for the different sections.</description>
    </item>
    
    <item>
      <title>Binding a simple list to a UITableView</title>
      <link>http://trycombine.com/posts/combinedatasources-simple-static-list/</link>
      <pubDate>Tue, 03 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>http://trycombine.com/posts/combinedatasources-simple-static-list/</guid>
      <description>While still keep improving the current version of CombineDataSources I tought it&amp;rsquo;d be nice to post few articles on the current API design along with some code samples.
This would be nice in order to get some feedback and to try putting some of the code in context.
CombineDataSources Introduction RxSwiftCommunity&amp;rsquo;s excellent RxDataSources allows developers to reactively bind data to table and collection views. It uses a lot of the underlaying structure of RxSwift and it&amp;rsquo;s very powerful.</description>
    </item>
    
    <item>
      <title>An assert operator: assertMaxSubscriptions()</title>
      <link>http://trycombine.com/posts/assert-max-subscriptions/</link>
      <pubDate>Thu, 29 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>http://trycombine.com/posts/assert-max-subscriptions/</guid>
      <description>While I keep working on CombineDataSources I&amp;rsquo;ve faced some of the differences between RxSwift and Combine and those are slowing me down a bit.
For example: in RxSwift when dealing with UI I&amp;rsquo;d usually use shareReplayLatestWhileConnected() - this operator shares an observable and emits the latest value to all subscribers downstream. In Combine there is currently a share() operator which does a similar thing but does not &amp;ldquo;replay&amp;rdquo; the latest value.</description>
    </item>
    
    <item>
      <title>Debug logging with CombinePrintout</title>
      <link>http://trycombine.com/posts/debug-logging-combineprintout/</link>
      <pubDate>Fri, 16 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>http://trycombine.com/posts/debug-logging-combineprintout/</guid>
      <description>Logging is a really powerful way to debug code, especially if it&amp;rsquo;s asynchronous code that runs in a time sensitive way so stepping through the debugger is a pain.
In Simple custom Combine operators I wrote about how to create an operator that logs to the system Console app in just few lines.
After playing with Combine some more I went ahead and created a micro framework called &amp;ldquo;CombinePrintout&amp;rdquo; that adds few convenient methods to Combine allowing you to quickly print information about your subscriptions.</description>
    </item>
    
    <item>
      <title>Building a custom `sample` operator</title>
      <link>http://trycombine.com/posts/more-simple-custom-combine-operators-with-sample/</link>
      <pubDate>Tue, 06 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>http://trycombine.com/posts/more-simple-custom-combine-operators-with-sample/</guid>
      <description>In Simple custom Combine operators I spoke about how you can cheaply create your own custom Combine operator without the need to create a new custom Publisher type.
In this post I&amp;rsquo;d like to show how this kind of &amp;ldquo;cheap&amp;rdquo; operators could actually be quite complex and useful; still being created only by creatively combining existing operators.
Let&amp;rsquo;s look at sample(_)&amp;hellip;
The sample operator rxmarbles.com is a marveleous website where you can find visual and interactive presentations of a multitude of reactive operators (based in their implementation in RxJS).</description>
    </item>
    
    <item>
      <title>Simple custom Combine operators</title>
      <link>http://trycombine.com/posts/simple-custom-combine-operators/</link>
      <pubDate>Fri, 02 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>http://trycombine.com/posts/simple-custom-combine-operators/</guid>
      <description>Creating simple custom operators is very straightforward in Combine.
As long as your custom operator can be expressed via combining existing operators you don&amp;rsquo;t need to create a new publisher type - you can simply extend the Publisher protocol with your own custom operator.
Let&amp;rsquo;s try quickly creating one now.
Extending Publisher You can extend Publisher like any other protocol in Swift. For this post I&amp;rsquo;ll create a debugging operator that writes logs to the system console.</description>
    </item>
    
  </channel>
</rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>task on try Code</title>
    <link>https://trycombine.com/tags/task/</link>
    <description>Recent content in task on try Code</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 06 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://trycombine.com/tags/task/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Actors, the cooperative pool and concurrency</title>
      <link>https://trycombine.com/posts/swift-actor-dispatch-queues-concurrency/</link>
      <pubDate>Wed, 06 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-actor-dispatch-queues-concurrency/</guid>
      <description>After I started doing some benchmarking how different APIs perform, when used to build a simple counter, I got really interested to learn more about how the new Swift concurrency model behaves at runtime.
So in this post I&amp;rsquo;ll use a couple of actors and make them do concurrent computations and check how the thread list and dispatch-queues look like in the debugger.
The Test Setup I&amp;rsquo;ve prepared a super-duper simple SwiftUI app that does a bunch of floating-point multiplication and division.</description>
    </item>
    
    <item>
      <title>Performance: Actor vs queue vs lock</title>
      <link>https://trycombine.com/posts/performance-actor-queue-lock-benchmark/</link>
      <pubDate>Thu, 30 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/performance-actor-queue-lock-benchmark/</guid>
      <description>I do a lot of performance and instrumenting work and I&amp;rsquo;ve found Peter Steinberger&amp;rsquo;s post here very useful when comparing lock alternatives.
As I worked with async/await and actors more and more this summer, I thought it’d be nice to put together a short post offering some basic benchmarking of actors vs. the existing synchronization mechanisms.
Disclaimer Benchmarking depends heavily on the system, temporary conditions, and more. As with any amateur benchmarks, take the numbers in this post with a grain of salt.</description>
    </item>
    
    <item>
      <title>The difference between Thread.sleep() and Task.sleep()</title>
      <link>https://trycombine.com/posts/thread-task-sleep/</link>
      <pubDate>Mon, 13 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/thread-task-sleep/</guid>
      <description>With the work-in-progress backport of the new Swift concurrency model all the way to iOS13, async/await and friends are getting more and more relevant for all Swift developers.
So here&amp;rsquo;s a quick and simple example that showcases some of the nice features of the new concurrency model without going into much detail.
Thread.sleep() vs Task.sleep() Let&amp;rsquo;s just look at the old and new sleep APIs:
  Thread.sleep() is the old API that blocks a thread for the given amount of seconds — it doesn&amp;rsquo;t load the CPU, the core just idles.</description>
    </item>
    
  </channel>
</rss>

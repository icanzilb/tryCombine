<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Combine on try Combine</title>
    <link>http://trycombine.com/tags/combine/</link>
    <description>Recent content in Combine on try Combine</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 13 Mar 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://trycombine.com/tags/combine/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Timelane - the first two weeks!</title>
      <link>http://trycombine.com/posts/timelane-combine-update/</link>
      <pubDate>Fri, 13 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>http://trycombine.com/posts/timelane-combine-update/</guid>
      <description>It&amp;rsquo;s been two weeks since I released Timelane and I&amp;rsquo;m really humbled by the community&amp;rsquo;s super positive response.
Since much has happened since the launch, I&amp;rsquo;m writing this to give everyone a detailed update.
The current versions are as follows:
 TimelaneCombine 1.0.4 RxTimelane 1.0.3 TimelaneCore 1.0.3  I&amp;rsquo;ve merged 18 PRs (in the 14 days since launch!) on all Timelane repos and I pushed some changes myself too.</description>
    </item>
    
    <item>
      <title>Announcing: Timelane</title>
      <link>http://trycombine.com/posts/announcing-timelane-combine/</link>
      <pubDate>Fri, 28 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>http://trycombine.com/posts/announcing-timelane-combine/</guid>
      <description>Today I&amp;rsquo;m announcing the public release of Timelane.
Timelane is a free, open source Instrument that helps you profile and debug asynchronous code.
Timelane is available today on: http://timelane.tools.
The Timelane Instrument leverages signpost logging and the powerful Instruments UI to help you visually inspect asynchronous subscriptions and drill down through logged events over time.
Installation Install the latest build from http://timelane.tools or fork the repository on GitHub and build the app yourself.</description>
    </item>
    
    <item>
      <title>Property Wrappers with Combine</title>
      <link>http://trycombine.com/posts/combine-property-wrappers/</link>
      <pubDate>Wed, 11 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>http://trycombine.com/posts/combine-property-wrappers/</guid>
      <description>In this post I&amp;rsquo;ll look into making more out of Combine code by using the newly introduced in Swift 5.1: Property Wrappers.
Let&amp;rsquo;s very quickly go into what property wrappers are in general and then dive into a Combine example.
Swift Property Wrappers Property wrappers are a new feature in Swift 5.1 that allows you to abstract redundant functionality around handling type properties.
Property wrappers are very handy in (my experience so far ðŸ¤“ ) two ways:</description>
    </item>
    
    <item>
      <title>subscribe(on:) vs receive(on:)</title>
      <link>http://trycombine.com/posts/subscribe-on-receive-on/</link>
      <pubDate>Mon, 09 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>http://trycombine.com/posts/subscribe-on-receive-on/</guid>
      <description>In this post, instead of looking into the basics of multi-threading with Combine, we are going to have a look at the difference between subscribe(on:) and receive(on:) specifically.
We&amp;rsquo;re going to look at a typical subscription chain starting with a root publisher, a couple of operators, and a subscriber at the end.
We&amp;rsquo;ll look into more diagrams and some example code of how subscribe(on:) and receive(on:) affect subscriptions.
subscribe(on:) subscribe(on:) sets the scheduler on which you&amp;rsquo;d like the current subscription to be &amp;ldquo;managed&amp;rdquo; on.</description>
    </item>
    
    <item>
      <title>Binding a list with multiple sections and different cells</title>
      <link>http://trycombine.com/posts/combinedatasources-multiple-sections/</link>
      <pubDate>Sat, 07 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>http://trycombine.com/posts/combinedatasources-multiple-sections/</guid>
      <description>Today&amp;rsquo;s post showcases another real-life use case of using CombineDataSources, namely binding a list to a table view with multiple sections using different cell types.
In my last post Binding a simple list to a UITableView we had a look at binding a list of data elements to a table view. It&amp;rsquo;s pretty simple to bind a plain table view when you have a coherent list of elements.
In this post I&amp;rsquo;m gonna show some code on how to bind a list to a table with multiple sections that also needs to use different cell types for the different sections.</description>
    </item>
    
    <item>
      <title>Binding a simple list to a UITableView</title>
      <link>http://trycombine.com/posts/combinedatasources-simple-static-list/</link>
      <pubDate>Tue, 03 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>http://trycombine.com/posts/combinedatasources-simple-static-list/</guid>
      <description>While still keep improving the current version of CombineDataSources I tought it&amp;rsquo;d be nice to post few articles on the current API design along with some code samples.
This would be nice in order to get some feedback and to try putting some of the code in context.
CombineDataSources Introduction RxSwiftCommunity&amp;rsquo;s excellent RxDataSources allows developers to reactively bind data to table and collection views. It uses a lot of the underlaying structure of RxSwift and it&amp;rsquo;s very powerful.</description>
    </item>
    
    <item>
      <title>An assert operator: assertMaxSubscriptions()</title>
      <link>http://trycombine.com/posts/assert-max-subscriptions/</link>
      <pubDate>Thu, 29 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>http://trycombine.com/posts/assert-max-subscriptions/</guid>
      <description>While I keep working on CombineDataSources I&amp;rsquo;ve faced some of the differences between RxSwift and Combine and those are slowing me down a bit.
For example: in RxSwift when dealing with UI I&amp;rsquo;d usually use shareReplayLatestWhileConnected() - this operator shares an observable and emits the latest value to all subscribers downstream. In Combine there is currently a share() operator which does a similar thing but does not &amp;ldquo;replay&amp;rdquo; the latest value.</description>
    </item>
    
    <item>
      <title>Debug logging with CombinePrintout</title>
      <link>http://trycombine.com/posts/debug-logging-combineprintout/</link>
      <pubDate>Fri, 16 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>http://trycombine.com/posts/debug-logging-combineprintout/</guid>
      <description>Logging is a really powerful way to debug code, especially if it&amp;rsquo;s asynchronous code that runs in a time sensitive way so stepping through the debugger is a pain.
In Simple custom Combine operators I wrote about how to create an operator that logs to the system Console app in just few lines.
After playing with Combine some more I went ahead and created a micro framework called &amp;ldquo;CombinePrintout&amp;rdquo; that adds few convenient methods to Combine allowing you to quickly print information about your subscriptions.</description>
    </item>
    
    <item>
      <title>Building a custom `sample` operator</title>
      <link>http://trycombine.com/posts/more-simple-custom-combine-operators-with-sample/</link>
      <pubDate>Tue, 06 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>http://trycombine.com/posts/more-simple-custom-combine-operators-with-sample/</guid>
      <description>In Simple custom Combine operators I spoke about how you can cheaply create your own custom Combine operator without the need to create a new custom Publisher type.
In this post I&amp;rsquo;d like to show how this kind of &amp;ldquo;cheap&amp;rdquo; operators could actually be quite complex and useful; still being created only by creatively combining existing operators.
Let&amp;rsquo;s look at sample(_)&amp;hellip;
The sample operator rxmarbles.com is a marveleous website where you can find visual and interactive presentations of a multitude of reactive operators (based in their implementation in RxJS).</description>
    </item>
    
    <item>
      <title>Simple custom Combine operators</title>
      <link>http://trycombine.com/posts/simple-custom-combine-operators/</link>
      <pubDate>Fri, 02 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>http://trycombine.com/posts/simple-custom-combine-operators/</guid>
      <description>Creating simple custom operators is very straightforward in Combine.
As long as your custom operator can be expressed via combining existing operators you don&amp;rsquo;t need to create a new publisher type - you can simply extend the Publisher protocol with your own custom operator.
Let&amp;rsquo;s try quickly creating one now.
Extending Publisher You can extend Publisher like any other protocol in Swift. For this post I&amp;rsquo;ll create a debugging operator that writes logs to the system console.</description>
    </item>
    
  </channel>
</rss>
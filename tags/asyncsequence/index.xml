<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>asyncsequence on try Code</title>
    <link>https://trycombine.com/tags/asyncsequence/</link>
    <description>Recent content in asyncsequence on try Code</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 21 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://trycombine.com/tags/asyncsequence/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Swift Async Sequence extensions (part 2)</title>
      <link>https://trycombine.com/posts/swift-async-sequence-extensions-2/</link>
      <pubDate>Fri, 21 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-async-sequence-extensions-2/</guid>
      <description>In Swift Async Sequence extensions (part 1) I covered simple ways to create an async sequence using a custom factory method and binding a sequence to a UI control via a custom assign method.
This covered the &amp;ldquo;beginning&amp;rdquo; and &amp;ldquo;end&amp;rdquo; of the data stream (so to say) but what about processing or converting the data along the way? If you draw a parallel to Combine code â€” how would you build custom &amp;ldquo;operators&amp;rdquo; for your async sequence?</description>
    </item>
    
    <item>
      <title>Swift Async Sequence extensions (part 1)</title>
      <link>https://trycombine.com/posts/swift-async-sequence-extensions-1/</link>
      <pubDate>Wed, 19 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-async-sequence-extensions-1/</guid>
      <description>I&amp;rsquo;ve been trying out various ways to extend and build upon the currently available Concurrency APIs introduced in Swift 5.5
I believe the Concurrency APIs are intentionally somewhat minimal so that developers would intentionally fall back on Combine for complex tasks. Maybe I&amp;rsquo;m right or wrong but I can see how a lot of people will want to extend the Concurrency APIs to suit better their current tasks.
In this post I&amp;rsquo;ll code a couple of extensions that show how to easily build your own concurrent power-ups.</description>
    </item>
    
    <item>
      <title>Bridge from Combine to AsyncSequence - the code (p. 2)</title>
      <link>https://trycombine.com/posts/combine-async-sequence-2/</link>
      <pubDate>Tue, 13 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/combine-async-sequence-2/</guid>
      <description>Yesterday I wrote about AsyncSequence, AsyncStream and a simple plan how to bridge (or proxy) Combine publishers to the new asynchronous sequences APIs - Bridge from Combine to AsyncSequence - the plan (part 1).
Today let&amp;rsquo;s put together the code as planned and see if that&amp;rsquo;s going to work out so we can easily use publishers as async sequences.
CombineAsyncStream setup I&amp;rsquo;ll create a new type called CombineAsyncStream and make it conform to AsyncSequence.</description>
    </item>
    
    <item>
      <title>Bridge from Combine to AsyncSequence - the plan (p. 1)</title>
      <link>https://trycombine.com/posts/combine-async-sequence-1/</link>
      <pubDate>Mon, 12 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/combine-async-sequence-1/</guid>
      <description>Previously, I wrote about actors in Actors part 1 and Actors part 2; this time I&amp;rsquo;m going to cover how to write a Combine operator to proxy a Combine publisher into an async sequence that you can iterate over by using a simple for loop.
Note: The current version of Xcode 13 is beta 2 and I&amp;rsquo;m going to be using the latest swift.org toolchain nightly snapshot in order to make use of AsyncStream.</description>
    </item>
    
  </channel>
</rss>

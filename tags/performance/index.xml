<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>performance on try Code</title>
    <link>https://trycombine.com/tags/performance/</link>
    <description>Recent content in performance on try Code</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 20 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://trycombine.com/tags/performance/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introducing timeui</title>
      <link>https://trycombine.com/posts/introducing-timeui/</link>
      <pubDate>Sun, 20 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/introducing-timeui/</guid>
      <description>A little while ago I coded a minimal profiling tool for the macOS command line and called it timeui. Last week I pushed the source code online in the hope other people would like it and use it (and eventually contribute some code too).
In this post I&amp;rsquo;ll introduce you quickly to timeui and what it can currently do for you.
What is timeui? timeui is a command line tool that profiles an app you provide it and shows duration, apple&amp;rsquo;s universal logging intervals, CPU usage and memory footprint:</description>
    </item>
    
    <item>
      <title>Optimization in Swift, part 4</title>
      <link>https://trycombine.com/posts/swift-performance-concurrency-4/</link>
      <pubDate>Mon, 14 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-performance-concurrency-4/</guid>
      <description>In Part 3 I wrote about trying to optimize my filter code by using an unsafe API from the standard library. This helped a tiny bit but barely improved the performance of my initial fictional use case (all about the test setup you can find out in Part 1).
Updating the Memory Buffer Concurrently Looking at the results of both code variants so far, I got an idea — I could fuse together using concurrency to do the collection filtering and using a buffer in memory so I can update the array storage directly.</description>
    </item>
    
    <item>
      <title>Optimization in Swift, part 3</title>
      <link>https://trycombine.com/posts/swift-performance-concurrency-3/</link>
      <pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-performance-concurrency-3/</guid>
      <description>In Part 2 I wrote about trying to optimize a very tight filter function with async/await. This helped when the filter performs some heavy work for each of the collection elements but not with my initial fictional use case (all about the test setup you can find out in Part 1).
Taking to the Standard Library Since I already know that I&amp;rsquo;m not going to keep pushing the async/await variant of the code, I think it&amp;rsquo;s a good idea to look into the standard library.</description>
    </item>
    
    <item>
      <title>Optimization in Swift, part 2</title>
      <link>https://trycombine.com/posts/swift-performance-concurrency-2/</link>
      <pubDate>Wed, 09 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-performance-concurrency-2/</guid>
      <description>In Part 1 I wrote what this mini-series would be all about. Given the default array filtering is a performance bottleneck for my fictional app, I&amp;rsquo;m going to explore if I can write code that performs better in my specific use case.
In this part, I&amp;rsquo;m going to rewrite my initial filtering function and use the new async/await Swift concurrency syntax.
An async filter function Since TaskGroup still has a performance issue in the current version of Swift, I&amp;rsquo;ll use a simplified code that uses only top tasks (e.</description>
    </item>
    
    <item>
      <title>Optimization in Swift, part 1</title>
      <link>https://trycombine.com/posts/swift-performance-concurrency-1/</link>
      <pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-performance-concurrency-1/</guid>
      <description>This will be yet another exploratory series on my blog — this time around, I want to write a little about optimizing performance in Swift code. This is, of course, an endless topic so what I&amp;rsquo;m going to do is, similarly to previous posts, focus on a problem and then track my way through working on it.
Also, since this might turn into a somewhat longer read, I thought I&amp;rsquo;d split it into several short parts; so if you are in fact interested to read through you don&amp;rsquo;t have to put in all the time at once.</description>
    </item>
    
  </channel>
</rss>

<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>concurrency on try Code</title>
    <link>https://trycombine.com/tags/concurrency/</link>
    <description>Recent content in concurrency on try Code</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 10 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://trycombine.com/tags/concurrency/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Optimization in Swift, part 3</title>
      <link>https://trycombine.com/posts/swift-performance-concurrency-3/</link>
      <pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-performance-concurrency-3/</guid>
      <description>In Part 2 I wrote about trying to optimize a very tight filter function with async/await. This helped when the filter performs some heavy work for each of the collection elements but not with my initial fictional use case (all about the test setup you can find out in Part 1).
Taking to the Standard Library Since I already know that I&amp;rsquo;m not going to keep pushing the async/await variant of the code, I think it&amp;rsquo;s a good idea to look into the standard library.</description>
    </item>
    
    <item>
      <title>Optimization in Swift, part 2</title>
      <link>https://trycombine.com/posts/swift-performance-concurrency-2/</link>
      <pubDate>Wed, 09 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-performance-concurrency-2/</guid>
      <description>In Part 1 I wrote what this mini-series would be all about. Given the default array filtering is a performance bottleneck for my fictional app, I&amp;rsquo;m going to explore if I can write code that performs better in my specific use case.
In this part, I&amp;rsquo;m going to rewrite my initial filtering function and use the new async/await Swift concurrency syntax.
An async filter function Since TaskGroup still has a performance issue in the current version of Swift, I&amp;rsquo;ll use a simplified code that uses only top tasks (e.</description>
    </item>
    
    <item>
      <title>Optimization in Swift, part 1</title>
      <link>https://trycombine.com/posts/swift-performance-concurrency-1/</link>
      <pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-performance-concurrency-1/</guid>
      <description>This will be yet another exploratory series on my blog — this time around, I want to write a little about optimizing performance in Swift code. This is, of course, an endless topic so what I&amp;rsquo;m going to do is, similarly to previous posts, focus on a problem and then track my way through working on it.
Also, since this might turn into a somewhat longer read, I thought I&amp;rsquo;d split it into several short parts; so if you are in fact interested to read through you don&amp;rsquo;t have to put in all the time at once.</description>
    </item>
    
    <item>
      <title>TaskGroup as a workflow design tool</title>
      <link>https://trycombine.com/posts/swift-concurrency-task-group-workflow/</link>
      <pubDate>Mon, 21 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-concurrency-task-group-workflow/</guid>
      <description>For my talk at iOS Conf SG 2022 I wanted to showcase some Swift concurrency use-cases that don&amp;rsquo;t fall into the common scenarios. Revisiting the slides some weeks later, I think it&amp;rsquo;d be fun to cover my TaskGroup example in more detail.
In this post I&amp;rsquo;ll show how to use TaskGroup to design a complete (but fictional) user login-sequence.
What is TaskGroup good for? Most examples floating around show using a TaskGroup to add a number of identical tasks to a group and execute them concurrently.</description>
    </item>
    
    <item>
      <title>The issue with task groups or how I discovered a solved problem</title>
      <link>https://trycombine.com/posts/swift-concurrency-task-group/</link>
      <pubDate>Wed, 16 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-concurrency-task-group/</guid>
      <description>This post is not my usual format but there is a moral at the end, so hang around if you have a little time to waste.
The setup I&amp;rsquo;m working on a longer blog post about the process of optimizing some concurrency Swift code. At a point I used John Sundell&amp;rsquo;s CollectionConcurrencyKit to compare the performance of different approaches.
After I had my numbers, I peaked into his code to double check what exactly am I measuring.</description>
    </item>
    
    <item>
      <title>Announcing: “Modern Concurrency in Swift”</title>
      <link>https://trycombine.com/posts/announcing-modern-swift-concurrency-book/</link>
      <pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/announcing-modern-swift-concurrency-book/</guid>
      <description>I&amp;rsquo;m incredibly happy to share that today the new raywenderlich.com book &amp;ldquo;Modern Concurrency in Swift&amp;rdquo;, that I&amp;rsquo;ve been working on, is available at swiftconcurrencybook.com!
Together with editors Sandra Grauschopf, Felipe Laso-Marsetti, Richard Turton, and Shai Mishali, we&amp;rsquo;ve been working very hard to get a book out as soon as possible on the newly released in 2021 Swift Concurrency:
 The book is written in the classic raywenderlich.com style that mixes key pieces of theory with step-by-step instructions, guiding the readers through working on practical, real-life projects.</description>
    </item>
    
    <item>
      <title>Actors, the cooperative pool and concurrency</title>
      <link>https://trycombine.com/posts/swift-actor-dispatch-queues-concurrency/</link>
      <pubDate>Wed, 06 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-actor-dispatch-queues-concurrency/</guid>
      <description>After I started doing some benchmarking how different APIs perform, when used to build a simple counter, I got really interested to learn more about how the new Swift concurrency model behaves at runtime.
So in this post I&amp;rsquo;ll use a couple of actors and make them do concurrent computations and check how the thread list and dispatch-queues look like in the debugger.
The Test Setup I&amp;rsquo;ve prepared a super-duper simple SwiftUI app that does a bunch of floating-point multiplication and division.</description>
    </item>
    
    <item>
      <title>Performance: Actor vs queue vs lock</title>
      <link>https://trycombine.com/posts/performance-actor-queue-lock-benchmark/</link>
      <pubDate>Thu, 30 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/performance-actor-queue-lock-benchmark/</guid>
      <description>I do a lot of performance and instrumenting work and I&amp;rsquo;ve found Peter Steinberger&amp;rsquo;s post here very useful when comparing lock alternatives.
As I worked with async/await and actors more and more this summer, I thought it’d be nice to put together a short post offering some basic benchmarking of actors vs. the existing synchronization mechanisms.
Disclaimer Benchmarking depends heavily on the system, temporary conditions, and more. As with any amateur benchmarks, take the numbers in this post with a grain of salt.</description>
    </item>
    
    <item>
      <title>The difference between Thread.sleep() and Task.sleep()</title>
      <link>https://trycombine.com/posts/thread-task-sleep/</link>
      <pubDate>Mon, 13 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/thread-task-sleep/</guid>
      <description>With the work-in-progress backport of the new Swift concurrency model all the way to iOS13, async/await and friends are getting more and more relevant for all Swift developers.
So here&amp;rsquo;s a quick and simple example that showcases some of the nice features of the new concurrency model without going into much detail.
Thread.sleep() vs Task.sleep() Let&amp;rsquo;s just look at the old and new sleep APIs:
  Thread.sleep() is the old API that blocks a thread for the given amount of seconds — it doesn&amp;rsquo;t load the CPU, the core just idles.</description>
    </item>
    
    <item>
      <title>Bridge from Combine to AsyncSequence - the code (p. 2)</title>
      <link>https://trycombine.com/posts/combine-async-sequence-2/</link>
      <pubDate>Tue, 13 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/combine-async-sequence-2/</guid>
      <description>Yesterday I wrote about AsyncSequence, AsyncStream and a simple plan how to bridge (or proxy) Combine publishers to the new asynchronous sequences APIs - Bridge from Combine to AsyncSequence - the plan (part 1).
Today let&amp;rsquo;s put together the code as planned and see if that&amp;rsquo;s going to work out so we can easily use publishers as async sequences.
CombineAsyncStream setup I&amp;rsquo;ll create a new type called CombineAsyncStream and make it conform to AsyncSequence.</description>
    </item>
    
    <item>
      <title>Bridge from Combine to AsyncSequence - the plan (p. 1)</title>
      <link>https://trycombine.com/posts/combine-async-sequence-1/</link>
      <pubDate>Mon, 12 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/combine-async-sequence-1/</guid>
      <description>Previously, I wrote about actors in Actors part 1 and Actors part 2; this time I&amp;rsquo;m going to cover how to write a Combine operator to proxy a Combine publisher into an async sequence that you can iterate over by using a simple for loop.
 Note: The current version of Xcode 13 is beta 2 and I&amp;rsquo;m going to be using the latest swift.org toolchain nightly snapshot in order to make use of AsyncStream.</description>
    </item>
    
    <item>
      <title>Swift Actors: A practical example, part 2</title>
      <link>https://trycombine.com/posts/swift-actors-combine/</link>
      <pubDate>Wed, 12 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-actors-combine/</guid>
      <description>In my previous post Swift Actors: A practical example, part 1 I covered how I got a Swift.org toolchain from trunk, enabled support for the currently experimental support for structured concurrency, and created a thread-safe cache in few lines of Swift code.
If you missed part 1, definitely do read it first as this post builds upon the code I already covered there. »
When I wrapped up writing part 1, I was looking at my new cache actor and I started wondering &amp;ldquo;What about Combine?</description>
    </item>
    
    <item>
      <title>Swift Actors: A practical example, part 1</title>
      <link>https://trycombine.com/posts/swift-actors/</link>
      <pubDate>Mon, 10 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://trycombine.com/posts/swift-actors/</guid>
      <description>I&amp;rsquo;ve been re-reading the Swift structured concurrency roadmap and the Swift actors proposal and noticed a note on the latter saying:
 &amp;ldquo;Partially available in recent main snapshots behind the flag -Xfrontend -enable-experimental-concurrency&amp;rdquo;
 So, naturally 🤓, I downloaded the latest snapshot from Swift.org and took it for a spin to try out some actor code!
Installing Swift toolchain with actors support  Huge disclaimer: this is all experimental experience using a trunk code not cut into a release.</description>
    </item>
    
  </channel>
</rss>
